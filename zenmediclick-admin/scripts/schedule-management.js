/**
 * ZENMEDICLICK - GESTI√ìN DE HORARIOS
 * Funciones para administrar disponibilidad y horarios de m√©dicos
 */

// ==========================================
// DATOS DE HORARIOS Y DISPONIBILIDAD
// ==========================================

// Almac√©n de horarios de m√©dicos
let doctorSchedules = {
    'dr-rodriguez': {
        name: 'Dr. Carlos Rodr√≠guez',
        specialty: 'Cardiolog√≠a',
        schedule: {
            monday: { start: '08:00', end: '12:00', active: true },
            tuesday: { start: '08:00', end: '12:00', active: true },
            wednesday: { start: '14:00', end: '18:00', active: true },
            thursday: { start: '08:00', end: '12:00', active: true },
            friday: { start: '08:00', end: '12:00', active: true },
            saturday: { start: '', end: '', active: false },
            sunday: { start: '', end: '', active: false }
        },
        exceptions: [], // D√≠as especiales sin disponibilidad
        lastUpdated: new Date().toISOString()
    },
    'dra-martinez': {
        name: 'Dra. Ana Mart√≠nez',
        specialty: 'Pediatr√≠a',
        schedule: {
            monday: { start: '09:00', end: '13:00', active: true },
            tuesday: { start: '09:00', end: '13:00', active: true },
            wednesday: { start: '15:00', end: '19:00', active: true },
            thursday: { start: '09:00', end: '13:00', active: true },
            friday: { start: '09:00', end: '13:00', active: true },
            saturday: { start: '', end: '', active: false },
            sunday: { start: '', end: '', active: false }
        },
        exceptions: [],
        lastUpdated: new Date().toISOString()
    }
};

// D√≠as de la semana
const weekDays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
const dayNames = {
    monday: 'Lunes',
    tuesday: 'Martes', 
    wednesday: 'Mi√©rcoles',
    thursday: 'Jueves',
    friday: 'Viernes',
    saturday: 'S√°bado',
    sunday: 'Domingo'
};

// ==========================================
// FUNCIONES PRINCIPALES DE HORARIOS
// ==========================================

/**
 * Agregar nueva disponibilidad
 */
function addAvailability() {
    const selectedDoctor = document.getElementById('doctorSelect').value;
    
    if (!selectedDoctor) {
        showMessage('‚ùå Por favor selecciona un m√©dico', 'error');
        return;
    }
    
    const scheduleData = collectScheduleData();
    const validation = validateScheduleData(scheduleData);
    
    if (!validation.isValid) {
        showMessage(`‚ùå ${validation.message}`, 'error');
        return;
    }
    
    // Actualizar horarios del m√©dico
    updateDoctorSchedule(selectedDoctor, scheduleData);
    
    showMessage('‚ûï Nueva disponibilidad agregada correctamente', 'success');
    logAuditAction('ADD_AVAILABILITY', selectedDoctor, { schedule: scheduleData });
}

/**
 * Guardar cambios de horario
 */
function saveScheduleChanges() {
    const selectedDoctor = document.getElementById('doctorSelect').value;
    
    if (!selectedDoctor) {
        showMessage('‚ùå Por favor selecciona un m√©dico', 'error');
        return;
    }
    
    const scheduleData = collectScheduleData();
    const validation = validateScheduleData(scheduleData);
    
    if (!validation.isValid) {
        showMessage(`‚ùå ${validation.message}`, 'error');
        return;
    }
    
    // Confirmar cambios importantes
    if (hasSignificantChanges(selectedDoctor, scheduleData)) {
        if (!confirm('‚ö†Ô∏è Los cambios afectar√°n las citas existentes. ¬øContinuar?')) {
            return;
        }
    }
    
    // Guardar cambios
    updateDoctorSchedule(selectedDoctor, scheduleData);
    
    // Mostrar resumen de cambios
    showScheduleSummary(selectedDoctor);
    
    showMessage('üíæ Horarios guardados exitosamente', 'success');
    logAuditAction('SAVE_SCHEDULE_CHANGES', selectedDoctor, { newSchedule: scheduleData });
}

/**
 * Recolectar datos del formulario de horarios
 * @returns {Object} Datos de horario recolectados
 */
function collectScheduleData() {
    const schedule = {};
    
    weekDays.forEach(day => {
        const startElement = document.getElementById(`${day}-start`);
        const endElement = document.getElementById(`${day}-end`);
        
        if (startElement && endElement) {
            const start = startElement.value;
            const end = endElement.value;
            
            schedule[day] = {
                start: start,
                end: end,
                active: !!(start && end) // Activo si ambos campos tienen valor
            };
        }
    });
    
    return schedule;
}

/**
 * Validar datos de horario
 * @param {Object} scheduleData - Datos del horario a validar
 * @returns {Object} Resultado de validaci√≥n
 */
function validateScheduleData(scheduleData) {
    // Verificar que al menos un d√≠a est√© activo
    const activeDays = Object.values(scheduleData).filter(day => day.active);
    if (activeDays.length === 0) {
        return { isValid: false, message: 'Debe configurar al menos un d√≠a de disponibilidad' };
    }
    
    // Validar horarios l√≥gicos
    for (const [day, data] of Object.entries(scheduleData)) {
        if (data.active) {
            if (!data.start || !data.end) {
                return { 
                    isValid: false, 
                    message: `Horario incompleto para ${dayNames[day]}` 
                };
            }
            
            if (data.start >= data.end) {
                return { 
                    isValid: false, 
                    message: `Horario inv√°lido para ${dayNames[day]}: la hora de inicio debe ser anterior a la de fin` 
                };
            }
            
            // Validar duraci√≥n m√≠nima (30 minutos)
            const startMinutes = timeToMinutes(data.start);
            const endMinutes = timeToMinutes(data.end);
            if (endMinutes - startMinutes < 30) {
                return {
                    isValid: false,
                    message: `La disponibilidad m√≠nima debe ser de 30 minutos para ${dayNames[day]}`
                };
            }
        }
    }
    
    return { isValid: true };
}

/**
 * Convertir tiempo a minutos
 * @param {string} timeString - Tiempo en formato HH:MM
 * @returns {number} Minutos totales
 */
function timeToMinutes(timeString) {
    const [hours, minutes] = timeString.split(':').map(Number);
    return hours * 60 + minutes;
}

/**
 * Actualizar horario del m√©dico
 * @param {string} doctorId - ID del m√©dico
 * @param {Object} newSchedule - Nuevo horario
 */
function updateDoctorSchedule(doctorId, newSchedule) {
    if (!doctorSchedules[doctorId]) {
        doctorSchedules[doctorId] = {
            name: getDoctorName(doctorId),
            specialty: getDoctorSpecialty(doctorId),
            schedule: {},
            exceptions: [],
            lastUpdated: new Date().toISOString()
        };
    }
    
    doctorSchedules[doctorId].schedule = { ...newSchedule };
    doctorSchedules[doctorId].lastUpdated = new Date().toISOString();
    
    // En producci√≥n, aqu√≠ se enviar√≠a al servidor
    console.log('üíæ Horario actualizado:', doctorSchedules[doctorId]);
}

/**
 * Verificar si hay cambios significativos
 * @param {string} doctorId - ID del m√©dico
 * @param {Object} newSchedule - Nuevo horario
 * @returns {boolean} True si hay cambios significativos
 */
function hasSignificantChanges(doctorId, newSchedule) {
    if (!doctorSchedules[doctorId]) return true;
    
    const currentSchedule = doctorSchedules[doctorId].schedule;
    
    // Verificar si se desactivaron d√≠as que estaban activos
    for (const day of weekDays) {
        const wasActive = currentSchedule[day]?.active || false;
        const isActive = newSchedule[day]?.active || false;
        
        if (wasActive && !isActive) {
            return true; // Se desactiv√≥ un d√≠a que estaba disponible
        }
        
        // Verificar cambios de horario en d√≠as activos
        if (wasActive && isActive) {
            if (currentSchedule[day].start !== newSchedule[day].start ||
                currentSchedule[day].end !== newSchedule[day].end) {
                return true;
            }
        }
    }
    
    return false;
}

// ==========================================
// VISUALIZACI√ìN Y CARGA DE HORARIOS
// ==========================================

/**
 * Cargar horario del m√©dico seleccionado
 */
function loadDoctorSchedule() {
    const selectedDoctor = document.getElementById('doctorSelect').value;
    
    if (!selectedDoctor) {
        clearScheduleForm();
        return;
    }
    
    const doctorData = doctorSchedules[selectedDoctor];
    
    if (doctorData && doctorData.schedule) {
        // Cargar horarios existentes
        weekDays.forEach(day => {
            const startElement = document.getElementById(`${day}-start`);
            const endElement = document.getElementById(`${day}-end`);
            
            if (startElement && endElement && doctorData.schedule[day]) {
                startElement.value = doctorData.schedule[day].start || '';
                endElement.value = doctorData.schedule[day].end || '';
            }
        });
        
        showMessage(`üìÖ Horarios cargados para ${doctorData.name}`, 'info');
    } else {
        clearScheduleForm();
        showMessage(`‚ÑπÔ∏è No hay horarios configurados para este m√©dico`, 'info');
    }
}

/**
 * Limpiar formulario de horarios
 */
function clearScheduleForm() {
    weekDays.forEach(day => {
        const startElement = document.getElementById(`${day}-start`);
        const endElement = document.getElementById(`${day}-end`);
        
        if (startElement && endElement) {
            startElement.value = '';
            endElement.value = '';
        }
    });
}

/**
 * Mostrar resumen de horarios
 * @param {string} doctorId - ID del m√©dico
 */
function showScheduleSummary(doctorId) {
    const doctorData = doctorSchedules[doctorId];
    if (!doctorData) return;
    
    const activeDays = Object.entries(doctorData.schedule)
        .filter(([_, data]) => data.active)
        .map(([day, data]) => `${dayNames[day]}: ${data.start}-${data.end}`)
        .join('<br>');
    
    const totalHours = calculateWeeklyHours(doctorData.schedule);
    
    const summary = `
        üìã <strong>Resumen de Horarios - ${doctorData.name}</strong><br>
        üïí Horas semanales: ${totalHours.toFixed(1)} horas<br>
        üìÖ D√≠as activos:<br>${activeDays}
    `;
    
    showMessage(summary, 'success');
}

/**
 * Calcular horas semanales totales
 * @param {Object} schedule - Horario del m√©dico
 * @returns {number} Total de horas semanales
 */
function calculateWeeklyHours(schedule) {
    let totalMinutes = 0;
    
    Object.values(schedule).forEach(day => {
        if (day.active && day.start && day.end) {
            const startMinutes = timeToMinutes(day.start);
            const endMinutes = timeToMinutes(day.end);
            totalMinutes += endMinutes - startMinutes;
        }
    });
    
    return totalMinutes / 60; // Convertir a horas
}

// ==========================================
// GESTI√ìN DE EXCEPCIONES Y D√çAS ESPECIALES
// ==========================================

/**
 * Agregar excepci√≥n de d√≠a
 * @param {string} doctorId - ID del m√©dico
 * @param {string} date - Fecha de la excepci√≥n
 * @param {string} reason - Raz√≥n de la excepci√≥n
 */
function addScheduleException(doctorId, date, reason) {
    if (!doctorSchedules[doctorId]) return;
    
    const exception = {
        date: date,
        reason: reason,
        addedAt: new Date().toISOString(),
        addedBy: 'admin@zenmediclick.com'
    };
    
    doctorSchedules[doctorId].exceptions.push(exception);
    
    showMessage(`üö´ Excepci√≥n agregada para ${formatDate(date)}: ${reason}`, 'info');
    logAuditAction('ADD_SCHEDULE_EXCEPTION', doctorId, exception);
}

/**
 * Remover excepci√≥n de d√≠a
 * @param {string} doctorId - ID del m√©dico
 * @param {string} date - Fecha de la excepci√≥n a remover
 */
function removeScheduleException(doctorId, date) {
    if (!doctorSchedules[doctorId]) return;
    
    const initialLength = doctorSchedules[doctorId].exceptions.length;
    doctorSchedules[doctorId].exceptions = doctorSchedules[doctorId].exceptions
        .filter(exception => exception.date !== date);
    
    if (doctorSchedules[doctorId].exceptions.length < initialLength) {
        showMessage(`‚úÖ Excepci√≥n removida para ${formatDate(date)}`, 'success');
        logAuditAction('REMOVE_SCHEDULE_EXCEPTION', doctorId, { date });
    }
}

// ==========================================
// UTILIDADES Y HELPERS
// ==========================================

/**
 * Obtener nombre del m√©dico por ID
 * @param {string} doctorId - ID del m√©dico
 * @returns {string} Nombre del m√©dico
 */
function getDoctorName(doctorId) {
    const doctorNames = {
        'dr-rodriguez': 'Dr. Carlos Rodr√≠guez',
        'dra-martinez': 'Dra. Ana Mart√≠nez',
        'dr-lopez': 'Dr. Miguel L√≥pez',
        'dra-garcia': 'Dra. Laura Garc√≠a'
    };
    return doctorNames[doctorId] || 'M√©dico Desconocido';
}

/**
 * Obtener especialidad del m√©dico por ID
 * @param {string} doctorId - ID del m√©dico
 * @returns {string} Especialidad del m√©dico
 */
function getDoctorSpecialty(doctorId) {
    const specialties = {
        'dr-rodriguez': 'Cardiolog√≠a',
        'dra-martinez': 'Pediatr√≠a',
        'dr-lopez': 'Neurolog√≠a',
        'dra-garcia': 'Ginecolog√≠a'
    };
    return specialties[doctorId] || 'Medicina General';
}

/**
 * Generar horarios disponibles para citas
 * @param {string} doctorId - ID del m√©dico
 * @param {string} date - Fecha para generar horarios
 * @returns {Array} Array de horarios disponibles
 */
function generateAvailableSlots(doctorId, date) {
    const doctorData = doctorSchedules[doctorId];
    if (!doctorData) return [];
    
    const dayOfWeek = new Date(date).toLocaleDateString('en-US', { weekday: 'lowercase' });
    const daySchedule = doctorData.schedule[dayOfWeek];
    
    if (!daySchedule || !daySchedule.active) return [];
    
    // Verificar excepciones
    const hasException = doctorData.exceptions.some(exc => exc.date === date);
    if (hasException) return [];
    
    // Generar slots de 30 minutos
    const slots = [];
    const startMinutes = timeToMinutes(daySchedule.start);
    const endMinutes = timeToMinutes(daySchedule.end);
    
    for (let minutes = startMinutes; minutes < endMinutes; minutes += 30) {
        const hours = Math.floor(minutes / 60);
        const mins = minutes % 60;
        const timeSlot = `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
        slots.push(timeSlot);
    }
    
    return slots;
}

// ==========================================
// EVENT LISTENERS
// ==========================================

// Configurar event listeners cuando el DOM est√© listo
document.addEventListener('DOMContentLoaded', function() {
    // Listener para cambio de m√©dico seleccionado
    const doctorSelect = document.getElementById('doctorSelect');
    if (doctorSelect) {
        doctorSelect.addEventListener('change', loadDoctorSchedule);
    }
    
    // Listener para validaci√≥n en tiempo real de horarios
    weekDays.forEach(day => {
        const startInput = document.getElementById(`${day}-start`);
        const endInput = document.getElementById(`${day}-end`);
        
        if (startInput && endInput) {
            [startInput, endInput].forEach(input => {
                input.addEventListener('change', validateTimeInputs);
            });
        }
    });
});

/**
 * Validar inputs de tiempo en tiempo real
 * @param {Event} event - Evento de cambio
 */
function validateTimeInputs(event) {
    const input = event.target;
    const dayMatch = input.id.match(/(\w+)-(start|end)/);
    
    if (!dayMatch) return;
    
    const [, day, type] = dayMatch;
    const startInput = document.getElementById(`${day}-start`);
    const endInput = document.getElementById(`${day}-end`);
    
    if (startInput.value && endInput.value) {
        if (startInput.value >= endInput.value) {
            input.style.borderColor = '#dc3545';
            showMessage(`‚ö†Ô∏è Horario inv√°lido para ${dayNames[day]}`, 'error');
        } else {
            startInput.style.borderColor = '#28a745';
            endInput.style.borderColor = '#28a745';
        }
    }
}